# Embedded Linux
Consists of:
- Bootloader
- Kernel
- File System
---
# File System
## File System Types
- SquashFS
- CramFS
- JFFS2
- YAFFS2
- ext2

## Compression Types
Usually IoT devices have limited storage and thus most of the time a compression algorithm is used in combination with the file systems mentioned above.


## Extracting file system from Firmware
> firmware = bootloader data + kernel data + file system 

### Identify Firmware type
#### Manual
Run the **file** utility to identify the file system type, architecture, etc ...
```bash
file firmware.bin
```

In Linux IoT devices the magic header of the file system is used to indicate the beginning of the file system section in the firmware. For example the SquashFS file system has the magic bytes "hsqs" at the beginning of the file system data. 

Use **hexdump** to dump the ascii representation of the firmware and identify the offset of the SquashFS magic bytes in the firmware.

```bash
hexdump -C RT-N300_3.0.0.4_378_9316-gb927772.trx | grep -i "hsqs"
```

![[Pasted image 20220613024231.png]]

Use dd to skip the first 0x000e2100 (the offset till the magic header of the SquashFS file system) bytes of the file and craft out the rest of the firemware into a file. The resulting file is a SquashFS file.

```bash
# evaluate expression
# $((1 + 1)) 
dd if=RT-N300_3.0.0.4_378_9316-gb927772.trx bs=1 skip=$((0x000e2100)) of=  
RT-N300_3.0.0.4_378_9316-gb927772.fs
```

Using the SquashFS utilities extract the file system contents

```bash
unsquashfs RT-N300_3.0.0.4_378_9316-gb927772.fs
```

#### Automated
Binwalk does the manual method but has a more exhaustive list of magic headers. It has automatic file system identification and extraction feature utilities.

```bash
# Identify sections in firmware
binwalk RT-N300_3.0.0.4_378_9316-gb927772.trx

# Identify Firmware Entropy
binwalk -E RT-N300_3.0.0.4_378_9316-gb927772.trx

# Identify and Extract sections from Firmware
binwalk -e RT-N300_3.0.0.4_378_9316-gb927772.trx
```

> NB. high entropy in firmware could be an indicator that the firmware is encrypted. 

## Static Analysis
### Manual
- Look for Private keys, certificates, weak default passwords. Some interesting files to look at
	- /etc/shadow
-  Look for custom binaries and identify if binary exploitation could used to escelate privileges
- Reverse engineer web application and applications on the file system.

### Automated
**firmwalker** is a simple bash script for searching the extracted or mounted firmware file system. It will search through the extracted or mounted firmware file system for things of intere
```bash
./firmwalker.sh ~/labs/Firmware/_netgear_wms5316_2.1.2.bin.extracted/wnc
```

## Dynamic Analysis
## Debug Binaries on the file system
### Identify architecture
Run the **file** utility on the binary to Identify the architecture of the firmware. 
```bash
file bin/busybox
```

![[Pasted image 20220613035310.png]]
Note the architecture from the file command output. For a more verbose output use the **readelf** utility. Also, note the endianess of the binary.

```bash
readelf -h bin/busybox
```

### Emulate the binary
Some of the libraries (so files) and dependencies used by the binaries of the firmware don't exist on your linux distro. And some of them are compiled for a different architecture. Use an emulator such as **qemu** to emulate running the binary.

> Using Chroot changes the root dir when running the binaries so the correct libaries and dependencies could be used from the /lib folder. This breaks qemu as it is built for your x86 machine. Hence, qemu tries loading the firmware /lib so files which are built for adifferent architecture. Thus, it breaks so we use the statically linked version of qemu. In that version the libaries are built inside the binary statically.

```bash
which qemu-mips-static

cp /usr/bin/qemu-mips-static .

sudo chroot . /qemu-mips-static bin/busybox id
```

### Debugging the binary
Check the system calls and library calls  made by the binary using strace and ltrace. Using the **manual** utility we could find the arguments to the system calls and what they mean.
```bash
sudo strace chroot . /qemu-mips-static bin/busybox id

sudo ltrace chroot . /qemu-mips-static bin/busybox id

# Find arguments for the write syscall
man 2 write
```

Run qemu with the -G flag to start remotely debugging the application. And hook into the application with gdb remote debugging.

```bash
sudo chroot . /qemu-mips-static -g 9999 bin/busybox id
```

Run gdb-multiarch to remotely attach to the binary.

```bash
gdb-multiarch bin/busybox

# Inside gdb run
set architecture mips

# Remote attach to binary 
target remote Â localhost:9999
```

